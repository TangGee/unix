多任务程序结构和工作原理 
    本届给出的内核实例由2个文件构成，一个是使用as86语言编制的引导启动程序boots，用于在计算机系统家电时从启动盘上的内核代码加载到内存中。另一个是使用GNU as 汇编语言编制的内核程序head.s，其中实现两个运行在特权级3上的任务在时钟中断控制下相互切换运行，并且还实现在屏幕是显示字符的一个系统调用。我们把这两个任务分别成为任务A和任务B（或任务0和任务1），他们会调用这个显示系统调用在屏幕上分别显示出字符‘A’，‘A’，直到每个10ms切换到另外一个任务。任务A连续循环地调用系统调用在屏幕上显示‘A’。任务B则一直显示字符‘B’。若要种植这个内核实例程序，则需要重新启动机器，或者关闭运行的模拟PC运行环境软件。
    boot.s程序编译出的代码共512字节，将被存放在软盘映像文件的第一山区中，见图4-39所示。PG及在加电启动时，ROM BIOS中的程序会把启动盘上的第一山区加载到物理内存07c00）31kb位置开始出，并把执行全转移到07c00处运行boot程序代码。
   boot程序的主要功能是把软盘或者映像文件中的head内核代码加载到内存某个制定的位置处，并在设置好临时GDT表等信息后，把处理里运行在保护模式下，然后跳转到head代码出去运行内核代码。实际上boot.s程序首先利用ROM BIOS中断int 0x13把软盘中的head代码读入到内存0x10000（64kb）位置开始处，然后再把这段head代码移动到内存0处。最后设置控制寄存器CR0中的开启保护运行行模式标志，并跳转到内存0开始处开始执行head代码。boot程序代码在内存中移动到head代码十一图见图4-40所示。
    把head内存代码移动到物理内存0开始处的主要原因是为了设置GDT表时可以简单一些，因而也能让head.s程序尽量短一些。但是我们不能让boot程序代码村软盘或者映像文件中直接加载到内存0处。因为加载操作需要使用ROM BIOS提供的终端过程，而BIOS使用的终端响亮表正处于内存0开始的地方，并且在内存1kb开始出是BIOS程序使用的数据区，所以若这届把head代码加载到内存0处将使得BIOS终端程序不能正常运行，当然我们也可以把head代码加载到内存0x1000处后直接运行head代码，使用这种方式的源程序可以从oldlinux.org网站下载，见下面说明。
    head.s程序运行在32位保护模式下，其中主要包括初始设置的代码时钟终端int 0x08的过程代码，系统调用终端int 0x80的过程代码以及任务A和任务B等的代码和数据。其中初始设置工作主要包括：重新设置GDT表;设置系统定时器芯片;重新设置IDT表并且设置始终和系统调用中断们;移动到任务A中执行。
    在虚拟地址空间中head.s程序的内核代码和任务代码分配如图4-41所示。实际上，本内核示例中所有代码和数据段都对应物理内存同一个区域上，即从物理内存0开始的区域。GDT中全局代码段和数据段描述副的内容都设置为：0x0000;段限长的值为0x07ff。因为颗粒度为1,所以实际代码的长度为8MB。而全局显示数据段被设置为基地址为0xb8000：段限长为0x0002,所以实际长度为8kb，对应到显示内存区域上。
    两个任务的在LDT中代码段和数据段的内容也都设置为：基地之0x0000：断肠为0x03ff，实际段长度为4MB。因此在现行地址空间中的这个“内核”带代码和数据段与任务段的代码和数据段代码都从线性地址0开始并且由于没有采用分页机制，所以他们都直接对应物理地址0开始出。在head程序编译出的目标文件中以及最终得到的软盘映像文件中代码段和数据段形式如图4-42所示
    由于处于特权级0的代码不能直接把控制权转移到特权3的代码中执行，但中断返回操作是可以的，因此当初始化GDT，IDT和定时芯片结束后，我们就利用终端返回指令IRET来启动运行第一个任务。具体实现方法是在初始堆栈initstack中人工设置一个返回环境。即把任务0的TSS段选择符加载到任务寄存器LTR中，LDT段选择副加载到LDTR中以后，把任务0的用户栈指针（0x17：init_stack）和代码指针（0x0f：task0）以及标志寄存器的值压入栈中，然后执行终端返回指令IRET，该指令会弹出堆栈上的指针作为任务0的用户栈指针，回复假设的任务0的标志寄存器内容，并且弹出栈中代码指针放入CS：EIP寄存器中，从而开始执行任务0的代码，完成了从特权级0到特权级3代码的控制转移。
    为了每个10ms切换运行的任务，head.s程序中把定时器芯片8253的通道0设置成每经10ms就像终端控制芯片8259A发送一个始终终端请求信号。PC机的ROM BIOS开机时已经在8250A中把始终终端请求信号设置成终端响亮8,因此我们只需要在终端8的处理过程中执行任务奇幻操作。任务切换的实现方法是查看current变量中当前变量中运行任务号。如果current当前是0,就领用任务1的TSS选择符作为操作数执行远跳指令，从而切换到任务1中执行，否则反之。
    每个任务在执行时，会首先把一个字符的ASCLL码放入寄存器AL中，然后调用系统终端调用int 0x80,而该系统调用处理器过程则会调用一个简单的字符卸载屏幕上，把寄存器AL中的字符显示在屏幕上，同时再把字符显示的屏幕的下一个位置记录下来，作为下一次显示字符的屏幕位置。在显示过一个字符后，任务代码会使用循环语句延迟一段时间，然后跳转到任务代码开始出继续循环执行，知道运行了10毫秒而发生了定时中断，从而代码会切换到另一个任务去运行。对于任务A，寄存器AL中将始终存放字符‘A’，而任务B运行时AL中始终存放字符‘B’。因此在程序运行时我们将看到一连串的字符‘A’，在任务B运行时AL中始终存放字符‘B’，因此我们在程序运行时我们将看到一连串的字符‘A’和一连串的字符‘B’，间隔地两需不断地显示在屏幕上，如图4-43所示。
    如4-43是我们子BOchs模拟软件中运行的内核示例在屏幕上显示情况。细心的读者会发现，在如中底端一行显示出一个字符‘C’。这是由于PC机偶然产生了一个不是始终终端的系统调用终端的其他终端。因为我们已经在程序中给所有其他终端安装了一个默认的处理程序。当出现一个其他终端时，系统就会运行这个默认的终端处理程序，于是就在屏幕上显示一个字符‘C’，然后退出终端。 
    下面给出boot.s和head.s程序的纤细注释。有关这个简单内核实力的编译和运行方法参考本书最后一张中“编译运行简单内核实力程序”一节内容。

4.9.2引导启动程序boot.s
     为了尽量让程序简单，这个引导启动山区程序仅能够加载长度不超过16个山区的head代码，并且直接使用ROM BIOS默认设置的终端向量号，即定时终端请求处理中断号仍然是8。这个Linux系统中使用的不同。Linux系统会在内核初始化时重新设置8259A中断控制芯片，并把始终终端请求信号对应到终端0x20上，详细说明参见“内核引导程序”一章内容。

任务管理
    任务（Task）是处理器可以分配调度，执行和挂起的一个工作单元。它可用于执行程序，任务和进程，操作系统服务，终端或一场处理过程和内核代码
	80x86提供了一种机制，这种机制可以用来保存任务状态，分派任务执行以及从一个任务切换到另一个任务。当工作在保护模式下，处理器所有运行都在任务中。即使是简单系统也必须起码定义一个任务。ganglia复杂的系统可以使处理器的任务管理功能支持多任务。
    80x86提供了多任务的硬件支持。任务是一个正在运行的程序，或者是一个等待准备运行的程序。通过中断，异常，跳转或调用，我们可以执行一个任务。当这些控制转移形式之一和某个描述符表中指定项的内容一起使用时。那么这个描述符是一类导致新任务开始执行的描述副。描述符表中与任务相关的描述符有两类：任务状态描述符和任务门。当执行权传给这任何一类描述符时，都会造成任务切换。
    任务切换很像过程调用，但任务切换会保存更多处理器。任务切换会把控制权完全转移到一个新的执行环境，即新任务的执行环境。这种转移操作要求保存处理器中几乎所有的寄存器的当前内容，包括标志寄存器EFLAGS和所有段寄存器。与过程不过，任务不可重入。任务切换不会把任何任务信息压入堆栈中。处理器的状态信息都被保存在内存中成为任务状态段（Task state segment）的数据结构中。

4.7.1 任务的结构和状态
    一个任务由两部分构成，任务执行空间和任务状态段TSS（Task-state segment）。任务执行空间包括代码段，堆栈段和一个或多个数据段，见图4-33所示。如果操作任务使用了处理器的特权级保护机制，那么任务执行空间就需要为每个特权级提供一个独立的堆栈空间。TSS制定了构成任务执行空间的各个段。TSS制定了构成任务执行空间的各个段，并且为任务状态信息提供存储空间。多任务环境中，TSS也为任务之间的链接提供了处理方法
    一个任务使用指向其TSS的段选择符来指定。当一个任务被加载进处理器执行时，那么该任务的段选择符，基地址，段限长以及TSS段描述符属性就会被加载进任务寄存器TR（Task Register）中。 如果使用了分页机制，那么任务使用的页目录表基地址就会被加载进控制寄存器CR3中。当前执行的任务的状态由处理器中的一下所有内容组成

4.7.3.2TSS描述符
    与其他段一样，任务状态段TSS也是使用段描述符来定义。图4-35给出了TSS描述符的格式。TSS描述符只能放在GDT中。
    类型字段TYPE中的忙标志B用于指明任务是否处于忙状态。忙状态的任务是当前正在执行任务或等待执行（被挂起）的任务。值为0b1001的类型字段表明任务处于非活动状态：而值为0b1001的类型字段表示任务正忙。任务是不可以递归执行的，因此处理器使用忙标志B来检测任务企图对被中断执行任务的调用。
     其中基地址，段限长，描述符特权级DPL，颗粒度G和存在位置具有与数据段描述符中相应字段同样的功能。在G=0时，限长字段被需大于等于103（0x67）的值，即TSS段的最小长度不的小于104字节。如果TSS段中还包含I/O许可位图，那么TSS段长读需要大一些。另外如果操作系统还想在TSS段中存放其它一些信息，那么TSS段就需要更大的长度。
     使用调用或跳转指令，任何可以访问TSS描述符的程序都能够造成任务切换，可以访问TSS描述符的程序其CPL数值必须小于或等于TSS描述符的程序都能够造成任务切换。在大多数系统中，TSS描述符的DPL字段应该设置成小于3.这样，whishing具有特权级的软件可以执行任务切换操作。然而在多任务应用中，某些TSS的DPL可以设置成3,以使得在用户特权级上也能就进行任务切换操作。
    可以访问一个TSS段描述符，并没有给程序可读写该描述符的能力。若想读或修改一个TSS段描述符，可以使用映射到内存相同位置的数据段描述符（即别名描述符 ）来操作。把TSS段描述符加载进任何段寄存器将导致一个异常。企图使用TI标志位选择符（即当前LDT中的选择符）来访问TSS段也将导致异常。

4.7.3.3 任务寄存器
    任务寄存器TR（Task Register）中存放着16位的段选择符以及当前任务TSS段的整个描述符（不可见部分）。这些信息从GDT中当前任务的TSS描述符中复制过来的。处理器使用任务寄存器TR的不可见部分来缓冲TSS段描述符内容。
    指令LTR和STR分别用于加载和保存任务寄存器的可见部分，即TSS段的选择符。LTR指令只能被特权级0的程序执行。LTR指令同茶馆用于系统初始化期间给TRJi村其加载初值（例如，任务0的TSS段选择符），随后在系统运行期间，TR的内容会被任务切换时自动改变。

4.7.3.4任务门描述符
    任务门描述符（task gate descriptor）提供对一个任务间接，受保护地引用，其格式见图所示。任务们描述符可以被存放在GDT，LDT或IDT表中。
    任务们描述符中的TSS选择符只想GDT中的一个TSS段描述符。这个TSS选择符。这个TSS选择符字段中的RPL域不用。任务门描述符中的DPL用于在任务切换时控制对于TSS段的访问。当程序通过任务门调用或跳转到一个任务时，程序的CPL以及指向任务们的门选择符的RPL值必须小于或等于任务们描述符DPL。请注意，当使用任务门时，目标TSS描述符的DPL忽略不用。
    程序可以通过任务门描述副或者TSS描述符来访问一个任务。图4-36示出了LDT，GDT和IDY鸟中的任务门都额uhe指向一个任务

4,4任务切换
处理器可以使用以下4中方式之一执行任务切换操作：
  1 当前任务对GDT中的TSS描述符执行JMP或CALL指令
  2当前任务对GDT或LDT中的任务门描述副执行JMP或CALL指令;
  3中断或一场指向IDT表中的任务们描述符。
  4当EFLAGS中的NT标志置位时当前恩无执行IRET指令。
JMP，CALL和IRET指令以及中断和异常都是处理器的普通机制，可以用于不发生在任务切换的环境中。对于TSS描述符或任务门引用（当调用或跳转到一个任务），或者NTBi奥之的状态（当执行IRET指令时）确定了是否发生任务切换。
   为了进行任务切换，JMP或CALL指令能够控制转移到制定的任务门中，见图4-37所示。
   当中断或异常的响亮索引的是IDT中的一个任务门时，一个中断或一场就会造成任务门切换。如果响亮索引的IDT中的一个中断或陷阱们，则不会造成任务切换。
   
   中断服务过程总是把执行权返回到被中断的过程中，被中断的过程可能在另一个任务中。如果NT标志处于复位状态，则执行一般返回处理。如果NT标志是置位状态，则返回操作会产生任务切换。切换任务到新任务由中断服务过程TSS中的TSS选择符（前一任务链接字段）指定。

