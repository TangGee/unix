对于硬盘和软盘设备上数据的读写操作是通过终端处理程序进行的。 内核每次读写数据量以一个逻辑块（1024 字节）为单位，而快设备控制器则是以山区（512）字节为单位。在处理过程中，使用了读写请求队列来顺序缓冲一次写多个逻辑快操作。
     当程序需要读取硬盘上的一个逻辑快时，就会想缓冲区管理程序提出盛情，而程序的进程则进入睡眠等待状态。 缓冲区管理程序首先在缓冲区寻找以前是否已经读取过这块数据。 如果缓冲区中已经有了，就直接将对应的缓冲区头指针返回给程序并唤醒该程序。 若缓冲区中还不存在所要球的数据块， 则缓冲管理程序就会调用本章中低级块读写函数ll_rw_nlock（）， 向相应的快设备驱动程序发出一个读数据的操作请求，该函数会为此创建一个请求结构，并插入请求队列中。 为了提供对写磁盘的效率，减少磁头移动的据另，在插入请求项时使用了电梯移动算法。
     此时，若对应块设备的请求项队列为空，则表明此刻该设备不忙，于是内核就会立刻想该块设备的控制器发出读数据命令。 当快设备的控制器将数据读入到指针的缓冲块中后，就会发出终端请求信号。并调用相应的读命令/当快设备的控制器将数据读到制定的缓冲块中后，就会发送终端请求信号，并调用相应的读命令后处理函数，处理继续读山区操作或者结束本次请求项的过程。 例如对相应快设备进行关闭操作和设置该缓冲区快快数据已经更新标志，最后唤醒等待该数据的进程。

9,11 块设备请求项目=和请求队列
    根据上面的描述，我们知道低级读写函数ll_rw_block（） 是通过请求项来与各种快设备建立联系并发出请求读写。对于各种快设备，年内和使用了一张块设备表blk_dev[] 来进行管理的。 每中快设备都在块设备表中占有一项。快设备表中的每个快设备的结构为

struct blk_dev_struct{
    void (*request_fn)(void);
struct request * current_request;
};
extern struct blk_dev_struct blk_dev[NR_BLK_DEV];


其中，地一个字段的一个函数指针，用于操作相应快设备请求项目=。例如，对于硬盘驱动程序，它是do_hd_request（），而对于软盘设备，它是do_floppy_request（），第二个字段的当前请求项结果哦指针，用于知名快设备目前正在处理请求项，初始化时都被设置为NULL
     快设备表将在内核初始化时，在init/main.c程序中调用各设备的初始化函数时被设置。 为了便于扩展Linus 把块设备表建成了一个以住设备号为索引的组织。 在LInux 0.11中，住设备号哟u7种。 其中住设备号 1,2和3分别对应块设备：虚拟盘，软盘和硬盘。 在块设备数组中其他各项目都被默认的设置成NULL
      当内核发出了设备读写或其他操作请求时 ， ll_rw_bloc（） 函数即会根据参数指明的操作名利和数据缓冲块头中的设备号，领用对uying球球u项操作函数do_XXX_request()建立一个块设备请求项（函数名的XXX可是是rd fd或hd，分别表示内存软盘和硬盘设备），并利用电梯算法插入到请求队列中。 请求队列由请求项数组中的项构成，共有32项，  每个请求项的数据结构如下所示。
struct request {
     int dev;
     int cmd;
     int errors;
     unsigned long sector;
     unsigned long nr_sectors;
     char *buffer;
     struct task_struct *waiting;
     struct buffer_head *bh;
     struct request *next;
}
extern struct request request[NR_REQUEST];

     每个块设备的当前请求指针与请求项数组中该设备的请求项链表共同构成了该设备的请求队列。项与项之间利用字段next指针形成链表。因此块设备项和相关的请求队列形成如下所是。请求项采用数组加链表结构的主要原因是为了满足两个目的： 一是利用请求项的数组结构在搜索空间请求块时尅进行循环操作，所所访问时间复杂度为常熟，因此程序可以编制的很简介。二是为了满足电梯算法插入请求操作，因此也需要采用链表结构。
   对于一个当前空闲的块神色被，当ll_rw_block（）函数为其建立地一个请求项时，会让该设备的当前请求指针current_request直接指向刚建立的请求，并且立刻调用对应设备的操作项操作函数开始执行块设备额i写操作。当一个块设备已经有几个请求项组成的链表存在，ll_rw_block（） 就会利用电梯算法，根据磁头移动距离最小原则，把新建的请求i项插入到链表和是的位置处。
    另外，为满足读操作的有限权，在建立新的请求项而搜索请求项数组时，把建立写操作时的空闲项所所范围限制在整个请求项目数组的2/3范围内，而剩下的1/2请求项专门给读操作建立请求项使用。
 
9.1.2 快设备访问调度处理
     想对于内存来说，访问硬盘和软盘等快设备中的数据是比较耗时并写形象系统性能的操作。由硬盘（或软盘）磁头寻到操作（即把读写次偶从一个次到移动到另一个制定次到上）需要话费很长时间，因此我们有必要在想硬盘控制器发送访问操作命令之前对读/写磁盘山区数据的顺序进行排序，即对请求项链表中各请求项的书需进行排序，是的所有请求访问的磁盘刷去数据都是尽量一次顺序进行操作。在Linux 0.2x内核中，该请求项排序使用的是电梯算法。其操作原理类似电梯运行的轨迹 向一个方向移动，知道该方向最后一个请求停止层位置。然后执行反向移动。对于磁盘来讲就是磁盘头一直向盘片圆心方向移动，或者反之现象盘片边缘移动 ，参见磁盘结构示意图。
      因此，内核并非按照收到请求的顺序直接发送给快设备进程处理。而是需要球球项的寻需进行处理。我们通常把相关的处理程序成为I/O调度程序。Linux 0.1x中的I/O调度程序
仅对请求项进行了排序处理，而当前流行的inux内核的IO 调度程序还包含对访问相邻磁盘山区的两个或多个请求的合并处理

9.1.3 块设备操作方式
     在系统（内核）与硬盘进行IO操作时， 需要考虑三个对象之间的交互作用。它们是系统。控制器和驱动器 ， 系统可以直接向控制器发送命令或等待控制器发出中断请求，控制器在及收到命令之后会控制驱动器的操作，读写数据或者进行i其他操作。因此我们可以把这里控制器发出的信号看作是这三者之间的同步擦uozuo信号，所经历的操作步骤为：
     首先系统知名控制器在执行名利结束而引发的中断过程中应该用的C函数，然后向快设备控制器发送读，写，复位或其他操作命令
   放钱控制器完成了制定的命令救护发出中断请求信号。引发系统执行快设备的终端处理过程，并在其中调用制定的C函数对读写或其它命令结束后的处理工作。

    对于写盘操作，系统需要发出了写名利后（使用fd_out（））等 带控制器给予润需想控制器写数据的相应没，也即需要查询等待控制器状态寄存器的数据请求服务DRQ置位。一旦DRQ置位，系统就可以想控制器缓冲区发送一个山区的书库。
     







