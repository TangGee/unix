这里仅给出和说明兼容显示卡端口的说明 。 描述了MDA，CGA，EGA和VGA显卡控制卡的通用编程端口，这写端口都是与CGA使用的MC6845芯片兼容，其名称和用途见表10-5所是。其中以CGA/EGA/VGA的端口（0x3d0-0x3df）为例进行说明， MDA的端口是0x3b0-0x3bf
     对于显示控制卡进行编程基本的步骤是： 首先把0-17值填写入显卡的索引寄存器 0x3d4，选择要进行设置的显示控制内部寄存器之一（r0-r17），此时数据寄存器端口0x3d5 对应到该内部寄存器上。然后就将参数写道该数据寄存器端口。也即显示卡的数据寄存器端口每次只能对显示卡中的一个内部寄存器进行操作。/没不寄存器见表10-6
0x3d4 写 C
    滚屏是指将制定开始行和结束行的一块文本内容向上移动或者向下移动， 即是窗口沿显示内存向下移动，将屏幕内容向下移动即是将框架偶向上移动。。 在程序中就是重新设置显示控制器中显示呢你村的开始位置origin以及调整程序中的相应变量。对于在两种操作各自都有两种情况。
  对于向上滚动，当屏幕对应的显示窗口在向下移动后仍然在显示内存范围之内的情况，也即对应当前屏幕的内存块卡是位置是中在显示内存的其实位置和末端位置之间，那么需要调整显示控制器中其实显示内存位置即可。但是当对应屏幕的内存快位置向下移动查处实际显示内存末端video_mem_end这种情况，就需要移动对应显示内存中的数据，一保证所有当前屏幕数据的都落在显示内存范围内，在这种情况，程序中是将屏幕对于内存数据一道实际显示内存的开始位置处
   曾需实际的处理过程分三步进行。 首先调整屏幕显示其实位置orign然后判断对应屏幕内存数据是否超出显示内存下界，如果超出就将屏幕对于的数据u移动到显示内存的开始处，最后对一定哦你屏幕上出现的新行用空格字符填满。见图10-8所是。 其中图（a）对应第一种简单情况 2 对应要一定哦你个内存是的情况
    终端控制命令
    终端通常有两部分功能，分别作为在计算机信息的输入设备（键盘）和输出设置 显示器。终端可有许多控制在命令。是的终端执行一定的操作而不是仅仅在屏幕上显示一个字符。使用这种方式，计算机就可以命令终端执行移动光标，切换显示模式和想铃等操作。终端控制命令又可以分为两类：种植字符命令和ANSI转移命令程序。 我们前面已经简单介绍linux内核中console.c程序实际上可以看作是模拟终端仿真程序。因此为了理解console.c程序的处理过程，我们该要的介绍一个终端设备ROM中程序如何处理从主机接收到书代码数据，我们首先简单描述ASCLL代码结果哦u，然后就说明设备如何处理接收到的控制字符和控制序列字符串代码
1 字符编码方法
     传统字符终端使用ANSI（American National Standards Institute，美国国家标准局）和ISO比赛偶像混夫人
  ASCLL码有7比特和8比特两种编码表示。7比特代码表共有128字符代码 
表中的字符被分为两种类型。一种是第1 第二列构成的控制字符 control character 其余是图形字符 或成为显示字符 ，文本字符。终端在接受到这两类字符时分别进行处理。 图形字符可以在屏幕上显示的字符。而控制字符则通常不会在屏幕上显示。 控制字符用于在数据通信和文本处理过程中其特殊控制作用。另外。DEL字符（0x7F）也是一个控制字符，而空格字符0x20 及可以是一般文本字符，也可以是一个控制字符使用。控制字符以及其功能是由ANSI标准化，其中的名称是ANSI标准的主机副。例如：CR 回车符 FF 换页符 CAN Cancel 取消符 通常7比特编码方式也使用与8比特的编码。表10-7是8比特代码表（其中左半个表与7比特代码表完全相同） 其中右办部分的哭奥站代码没有给出哦
     他比7比特代码表多出8列代码，共含有256个代码值。类似与7比特代码表，他是每行代码表8比特代码的低4比特值，而没列表示高4比特值。做面半个表与7比特代码表完全一样，他们代码的第8比特为0,因此该比特可以忽略。有面半个表 8-15列 中各代码的8在比特均为1 因此这些祖父只能在8比特环境中使用 8比特代码表有两个控制代码级 C0 和cq 。同时也有两个图形字符集。左图形字符集GL 和右图形字符集GR
C0和C1中控制字符的功能不能更改 ，但是我们可以把不同的显示字符映射到GL和或者GR区域中。
能够使用映射的各种文字字符集通常存储在终端设备中。在使用他们之前我们必须首先映射操作作为一斤为事实上标准的DEC终端设备来说，其中通常储存有DEC多过字符集。当打开终端设备时候，默认使用的就是DEC多过字符集
3控制功能
    为了指挥终端设备如何处理接收到的数据，我们就要使用终端设备的控制功能。主要通过发送控制代码或控制代码序列就可以控制终端设备读字符的显示处理，他们仅用作控制文本字符的显示，处理和
传送，而其本身并不显示在屏幕上。控制功能有许多用途。例如：在显示屏上移动光标位置，删除一行文本，更改字符，更改字符集和设置终端操作模式等。我们可以在文本模式中使用所有的控制功能，并用一个字节或多个自己表示控制功能。
   可以认为所有不用作在屏幕上的显示的控制字符或控制字符序列都是控制功能。在每个符合ANSI标准的终端设备中并不是所有控制功能都能执行控制操作没但是设备应该能够识别所有的功能，并忽略其中不起作用的控制功能，所以通常一个终端设备仅实现ANSI控制功能的一个子集。由于各种不同设备使用不同控制功能子集，因此与ANSI标准兼容并不以为这这些设备额相互兼容。兼容性仅体现在各种设备额使用相同的控制功能方面。
但自己控制功能就是C0和C1中的控制字符。使用C0中的控制字符就而已获得有限的控制功能，而C1中的控制字符可以另外提供一些控制功能，但只能在8比特环境中直接使用，因此Linux内核中所反正的CVT100型终端金额你那个使用C0中的控制字符。多自己额控制代码则可以提供更多的控制功能。这些多字节控制代码通常被转移为Esapce Sququeces 控制序列和设备控制字符串 其中有些控制序列是工业界通用的ANSI标准序列，另外一些则是生产厂商为自己产品使用设计的转悠控制序列。。像ANSI标准u序列一样，有转悠控制字符也符合ANSI字符代码的组合标注。

转义序列
    追究可以发送转移序列来控制终端屏幕上文本字符的显示和属性。转移序列由C0中控制字符ESC 0x1b开始，后面跟素一个或多个ASCII显示字符，转移序列的ANSI标准格式如下所示。

ESC是ANSI标准中定义的转移序列导码 在接受到引导ESC之后，终端需要以一定的寻需保存随后所有的控制字符
   中间字符 从ESC之后接收到的范围在0x20--0x2f的字符。终端需要把他们作为控制功能的一部分保存下来。
  结尾字符是ESC之后收到的范围在0x30--0x7e的字符
结尾字符指明转移字符结束。中间字符和结尾字符共同定义了一个序列的功能。此时终端即可以执行制定的功能并继续显示随后收到的字符。ANSI标准转意序列的结尾字符范围在 0x40-0x73 呵呵重大un设备生产厂家自己定义的转移序列结尾范围在0x40-0x3f 例如下面就是用来制定G0作为ASCII字符的转义序
列

由于转义序列仅使用7比特字符，因此我们可以在7比特和8比特环境中使用他们。注意当使用转移或控制序列时，请要记得它们定义的一个代码序列而非字符的文本表示，这里这些字符仅用作体现可读行。转移序列的重要用途是控制7比特控制字符的功能。ANSI标注
   通常我们可以在两方面使用上述代码扩展技术。我们可以使用2字符转移序列来表示8比特代码表C1中的任何控制字符，其中第2个字符的值是C1中对应字符值在0x40和0x5f之间的任何转义序列转换成生产一个8比特的控制字符
控制序列由控制字符CSI（0x9b）开始，后面跟随一个或多个ASCII图形字符
控制序列的ANSI标准格式如下所示
  通常我们可以在两方面使用上述代码空战技术。我们可以使用2转移字符

控制序列
    须知序列由控制字符CSI 开始，后面是跟随1或多个ASCII 图形字符：wq

异步串行通信传输的帧格式见图10-10所示。传输一个字符由开始位 数据位，奇偶校验位和停止位构成。。其中起始位起同步作用，值恒为0. 数据位是传输的实际数据，即一个字符的代码。其长度可以是5-8个比特。奇偶校验位可有可无，由程序设定。停止位横为1,可由程序
