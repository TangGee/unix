    linux/kernel/目录下共包括10个C语言文件和2个汇编语言文件以及一个kernel下编译文件的管理配置文件Makefile。 见列表8-1所是。对于其中三个子目录中代码的注释将在后续章节中进行。本章主要对13个代码文件进行注释。首先我们对所有程序的基本功能进行概括性的总体介绍，以便一开始就对这12个文件所实现的功能和它之间的相互调用关系有一个大致的了解，然后逐一对代码进行详细注释。
8.1 总体功能
    该目录下的代码文件从功能上可以分为三类。一类是硬件（异常）终端处理程序，一类是系统调用服务处理程序文件，另一类是进程调度等通用功能文件，参见图8-1,图2-17.我们现在根据这个分类方式从实现的功能上进行更详细的说明。
8.1.1中断处理程序
    主要包括两个代码文件：asm.s和tracs.c文件。asm.s用于实现大部分硬件异常所引起的中断汇编语言处理过程。而traps.c程序则实现了asm.s的中断处理过程中调用的c函数。另外几个硬件中断处理程序在文件system_call.s和mm/page.s中实现。有关PC机中8259A可变成中断控制芯片的链接及其功能请参见图5-21
5.7.4进程初始化
    在boot/目录中，引导程序把内核从磁盘加载到内存中，并让系统进程进入保护模式下运行后，就开始执行系统初始化程序init/main.c。该程序首先确定如何分配使用系统物理内存，然后调用内核各部分的初始化函数分别对内存管理，中断处理，快设备和字符设备，进程管理以及硬盘和软盘硬件进行初始化处理。在完成了这些操作之后，系统个部分已经处于可运行状态。此后程序把自己“手工”移动到任务0（进程0） 中运行，并使用fork（）调用首次创建进程1.在进程1中程序将继续执行应用环境的初始化和并执行shell登录程序。而原进程0则会在系统空闲时被调度执行，此时任务0仅执行pause（）系统调动用，其中又会去执行调度函数。
    “移动到任务0中执行”这个过程由宏move_to_user_mode(include/asm/system.h)完成。它把main.c程序执行流从内核态（特权0）移动到了用户态（特权级）的任务0中继续运行。在移动之前，系统在对调度程序的额初始化过程（sched_init()）中，首先对任务0的运行环境进行设置。这包括人工预先设置好任务0数据结构和字段的值（include/linux/sched。h），在全局描述符表中添加如任务0的任务状态段（TSS）描述符和局部描述符（LDT）的段描述符，并且把它们分别家在到任务寄存器tr和局部描述符表寄存器ldtr中
    这里需要强调的是，内核初始化是一个特殊的过程，内核初始化代码也即任务0的代码。从任务0数据结构中设置的初始数据可知，任务0的代码段和数据段的及地址0数据结构中设置的初始数据可知，任务0的代码段和数据段的及地址是0,段限长是640KB。而内核代码段和数据段的基地之是0,段限长是16MB，因此任务0的代码段和数据段分别包含在内核代码段和数据段中。内核初始化程序main.c也即是任务0中的代码，只是在移动到任务0之前系统正以内核太特权级0运行着main.c程序。宏move_to_user_mode的功能就是把运行特权级从内核态的0级别转换到用户态的3级，但是仍然继续执行原来的代码指令流。
    在移动到任务0的过程中，宏mov_to_user_mode使用了中断返回指令造成特权级改变的方法。使用这种方法进行控制权转移是由CPU保护机制造成的。CPU允许低级别（如特权级3）代码通过调用门或 
  


     在用户程序（进程）将控制权转交给终端处理程序之前CPU会首先将至少12字节（CFLAGS，CS和EIP）的信息压入终端处理程序的堆栈中，即进程的内核态代码中，见图8-2（a）所示，这种情况与一个远跳调用比较想象。CPU会代码段选择符和返回地址的偏移呀如堆栈。另一个与段间调用比较相像的地方是80386将信息压入到了目的代码（中断处理程序代码）的堆栈上，而不是被中断代码的堆栈中。如果优先级发生了变化，例如从用户级改变到内核系统级，CPU还会将原代码的堆栈段值和堆栈指针呀如中断程序的堆栈中。但是内核初始化完成后，内核代码执行时使用的是进程的内核态栈。因此这里目的代码的堆栈即是指进程的内核态堆栈，而被中断代码的对战当然也就是指进程的用户态堆栈了。所以当中断发生时，中断处理程序使用的是进程的内核态对战。另外，CPU还总是将标志寄存器EFLAGS的内容压入堆栈。对于具有优先级改变时的内容示意图如下
    asm.s代码文件主要设计对Intel保留中断int0-16的处理，其余保留的中断程序17-31由公司保留作今后扩充使用。对于终端控制器芯片发出的int32-int47的16个处理程序将分别在各种硬件（如时钟，键盘，软盘，数学斜处理器，硬盘等）初始化程序中处理。Linux系统调用终端int28（0x80）的处理则将在kernel/system_call.s中给出。各个终端的具体定义见代码注释后其它信息一届中的说明。  由于有些一场引起中断时，CPU内部会产生一个出错码呀如堆栈int 8   10-14
图8-2所示 而其他的终端却并不带有这个出错码（例如被零除出错和边界检查出错等）。因为 asm.s程序中会根据是否接待出错码而把终端程序分别进行处理。但处理流程还是一样的。
    对于一个硬件一场一起的终端的处理见过程8-3

功能描述 
    在linux 0.11中，用户使用中断调用int 0x80和放在寄存器eax中的功能号来使用内核提供的各种功能服务，在这些操作系统提供的功能被称之为系统调用功能。通常用户并不是直接使用系统调用中断，而是通过函数库中提供的接口函数来调用的。例如创建进程的系统调用fork可直接使用函数fork（）即可。函数胡库libc中的fork（）函数会实现对中断int 0x80的调用过程并把它调用结果返回给用户程序。
    对于所有系统调用的实现函数，内核把他们按照系统调用功能号顺序排列成一张函数指针表。然后在中断int 0x80 的处理过程中根据用户提供的功能号调用对应系统调用函数进行处理。
    本程序主要实现系统调用（system call） 中断int 0x80的入口处理过程以及信号检测处理，同时给出了两个系统功能底层接口，分别是sys_execve和sys_fork。来列出了处理过程类似的协处理器出错（int 16），设备不存在（int 17） ，时钟中断（int 32），硬盘中断（int 46），软盘中断 ，int38的中断处理程序
    对于软盘中断 sys_call coprocessor_error divice_not_available，其处理过程基本上是首先为调用相应C函数处理程序作准备，将一些参数压入堆栈。系统调用最多可以带3个参数，分别通过寄存器ebx,ecx,edx传如。然后叫用C函数进行相应功能的处理，处理返回后再去检测当前任务的信号位图，对值最小的一个信号进行处理并复位信号位图中的该信号好。系统调用的C语言处理函数分布在整个linux内核代码中，由include/linux/sys.h头文件中的系统函数指针数组表来匹配
    对与系统调用 int 0x80 的中断处理过程，可以把它看作是一个接口程序。实际上每个系统调用功能的处理过程基本上都是通过调用相应C函数进行的。即所谓的 bottom half函数。
    这个程序在刚进入时会首先检查eax中的功能号是否有效，然后保存一些会用到的寄存器到堆栈上。Linux内核默认地把段寄存器ds,es用于内核数据段，fs用于用户数据段。接着通过一个地址转换表调用相应的系统调用的C函数。在C函数返回后，程序就把返回值压入堆栈保存起来。
    接下来，该程序查看执行本次调用的进程状态。如果用于上面C函数的操作或其他情况而使进程的状态从执行态变成了其它状态。或者由于时间片已经用完，则调用进程调度函数schedule（） jmp _schedule 由于在执行jmp _schedule之前已经把返回地址ret_from_sys_call入栈，因此在执行完成schedule（）后最终会返回到ret_from_sys_call处继续执行。
   从ret_form_sys_call标号处开始执行的代码执行一些调用后的处理工作。主要判断当前进程是否是初始进程0,如果是就直接退出此次系统调用，中断返回。否则再更具代码段描述符和所使用的堆栈来判断本次系统调用的进程是否是一个普通进程，若不是则说明是内核进程  。
    但一个进程被执行时候  系统会设置其处理所有信号的方式为SIG——DEL 后SIG——IGN。 另外，当程序fork（）一个紫禁城时， 紫禁城会继续集成父进程的信号处理方式（信号掩码）/因此父进程对信号的设置处理方式在子进程中同样有效 
   为了能连续的不或一个制定的信号。signal（）函数的通常使用方式例子如系 

void sig_handler(int signr)
{
     signal(SIGINT,sig_handler);
     ....
}

main()
{
    signal(SIGINT ,sig handler);
    ....
}



 signal() 函数不可靠的原因在于当信号已经发生而进入自己设置的信号处理函数中，但重新再一次设置自己的处理句柄之前，在这段时间内可能又有一个信号发生。但是此时系统已经把处理句柄设置成默认值。因此就可能造成信号丢失。
    sgaction（） 函数采用sigcation 数据结构来保存制定信号的信息，它是一种可靠的内核函数处理机制。它可以让我们方便地查看或修改制定信号的处理句柄。 该函数是signal（）函数的一个超集。 该函数在include/signal.h头文件第66行中生明为
   int sigaction(int sig,struct sigaction * act , struct sigaction *oldact);

其中参数sig是我们需要查看或修改其信号处理句柄的信号，之后两个参数是sigaction结构的指针，当参数是act指针不是NULL时，就可以根据act结构中的信息修改制定信号的行为。当oldact不为空时，内核就会在该结构中返回信号原来的设置信息。sigaction结构见如下所示：
 struct sigaction{
     void (*sa_handler)(int);
      sigset_t sa_mask;
      int sa_flags;
      void(*sa_restore)(void);
}

当修改一个信号的处理方式时，如果处理sa_hander 不是默认的处理句柄SIG_DFL或忽略处理句柄SIG_IGN，那么在sa_handler处理句柄可被调用前，sa_mask字段就制定了需要加入到进程信号屏蔽位图中的一个信号集。如果信号处理句柄返回，系统就会回复进程原来的新你好屏蔽位图。这样在一个信号句柄被调用时，我们就可以阻塞指定的信号。 当信号句柄被调用时，新的信号屏蔽位图会自动地把当前发送的信号包括进去。阻塞该信号的继续发送。从而在我们处理制定信号期间能确保阻塞同一个信号不让其丢失，直到此次处理完毕。另外，在一个信号被阻塞期间而又有多次发生通常只保存其一个样例，也即在阻塞接触时对阻塞的多个统一信号智慧再调用一次信号处理句柄。在我们修改一个信号的处理句柄后，除非再次更改。否则就一直使用该处理句柄。这与传统的signal（）函数不一样。signal（）函数在一处理句柄结束后将其回复成信号处理句柄。
     sigaction 结构的sa_flag 用于制定其它一些处理信号的选项。这些选项的定义参见include/signal.h文件中 36-36行的说明。
     死噶抽屉哦你结构中的最后一个字段sys_signal（） 函数的参数restorer是一函数指针。它在编译链接程序时有libc函数库提供，用于信号处理程序结束后清理用户态堆栈，并回复系统调用存放在eax中的返回值，见西面的详细说明。
   do_signal（） 函数是内核系统调用（int 80） 终端处理程序中对信号预处理程序。在进程每次调用系统调用或这发生时钟终端时，如进行已收到信号没贼该函数会把信号的处理句柄（即对应的信号处理函数）插入到用户程序堆栈中这样在当前系统调用结束后就会另可执行信号处理句柄程序。然后再继续执行用户程序 。
    在把信号处理程序的参数插入到用户堆栈中之前，do_signal（） 函数首先会把用户程序堆栈指针向下扩展longs个长字， 然后将相关参数添加到其中，。由于do_signal（）函数从104行开始的代码比较难以理解，下面我们将对其详细描述。
     在用户程序调用系统调用将进入内核时，该进程的内核态堆栈由CPU压入如下所示内容。 也即：   用户程序的SS和ESP以及用户程序中吓一跳指令的执行点位置CS和EIP。在处理完此次制定的系统调用功能并具备调用do_signnal（）函数时，该进程的内核态堆栈上会


有
   咋do_Signal（） 处理完两个默认信号句柄SIG——IGN和SIG——DEL 之后，若用户定义了信号处理程序 信号句柄sa_handler 则从104行其do_signal（） 汗是准备把用户自定义的句柄插入用户态堆栈中。它首先把内核态对战中原esp减去longs值，把用户对战向下扩展了7或8个子长空间。最后把内核对象汗上的一些寄存器内容复制到这个用户空间，见图
    总共往用户态堆栈上放着了7到8个值，我们现在来说明这些值的含义以及防止这些值的u眼因。  old_eip即是原用户程序在调用系统调用之前的值。基本上也是调用系统调用的函数，eflags edx和ecx 是原用户程序在调用系统调用之前的值，基本上也是系统调用的参数，在系统调用返回后仍然需奥回复这些用户程序的寄存器值。eax中保存有系统调用的返回值。如果处理信号还润需收到本身，则对战上还存放该进程的阻塞码blocked 。下一个信号的signr值。
    最后一个信号活动恢复函数指针sa_restor。 这个回复函数不是用户设定个的，而是在用户定义signal()函数提供了一个信号值和一个信号处理句柄handler
     下面是SIGINT信号设置定义信号处理句柄的简单例子。默认情况下Ctrl-C组合键会产生SIGINT信号。
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handler(int sig)
{
     printf("The signal is %d\n", sig);
     (void) signal(SIGINT,SIG_DEL);

}

int main()
{
   (void) signal(SIGINT,handler);
   while(1)
   {
         printf("Signal test.\n");
         sleep();
   }
}
 其中，信号处理函数handler()会在信号SIGINT 出现时被调用执行。该函数首先输出一条信息，然后会把SIGINT信号处理过程设置成默认处理具备那个。因此在第二次按下Ctrl-c
组合键盘=时，SIG_DFL会让该程序结束运行。
   那么sa_restorer函数是从哪里来的呢  ？ 其实它是由函数哭提供的。在Linux的libc 2.2.2 函数库文件misc/子目录中有它的函数 ，定义如下哦
.globl __sig_restore
.globl __masksig_restore
__sig_restore:
    addl $4,%esp
    popl %eax
    popl %ecx
    popl %edx
    popfl
    ret
__masksig_restore:
   addl $4,%esp
   call __set_mask
   addl $4,%esp
   popl %ecx
   popl %edx
   popfl
   ret

该函数的主要作用是为了在信号处理程序结束后，回复用户程序执行系统调用后的返回值和一些寄存内容，并清楚作为信号处理程序参数的信号值signr，在编译链接用户自定义信号处理函数时。编译程序会调用Libc库中的系统调用函数把sa_restore（）函数插入到用户程序中。库文件中的信号系统调用的函数是下如下图所示。

#define __LIBRARY__
#include <unsistd.h>

extern void __sig_restore();
extern void __masksig_restore;

void (*signal (int sig,__sighandler_t func)) (int)
{
     void (*res)();
     register int __fooebx __asm__("bx") = sig;
     __asm__("int 0x80 ":"=a") (res);
     
}

sa_restorer（） 函数负责清理信号处理程序执行后回复用户程序的寄存器值和系统调用但会值，就好像没有运行过信号处理程序，而是直接从系统调用中返回
     最后说明一下执行的流程。在do_signal（） 执行完成后 ， system_call.s将会把进程内核堆栈上的eip一下的所有值都弹出堆栈。执行了iret指令之后，cpu将把内核态对战上的cs：eip， efags以及ss：esp弹出，回复到用户态去执行程序。由于esp已经被替换为指向信号处理句柄，因此，此刻即会立即执行用户自定义的信号处理程序。在信号处理程序执行后，通过ret指令，CPU救护把控制权一脚个sa_restore所只想的回复程序中去执行。而sa_restore程序会做一些用户堆栈态的清理工作，业绩会跳过对战上的信号好值signa，不能关切把系统调用后的返回eax和寄存器ecx，edx以及标志寄存器eflags弹出，完全回复了系统调用后各寄存器和CPU的状态。最后sa_restore的ret指令弹出原用户程序的eip（业绩堆栈上的old_eip），返回执行用户程序。




