ｇｄｂ　　ｒ是运行　　　ｎ是单步执行　　ｓ是追踪到函数内部　　　ｂｒｅａｋ设置断点　　　ｂｔ查看活动堆栈信息　　　ｐ　＜变量名＞　查看变量值　
ｌ查看围绕当前行的１０行代码　
ｐ　＜变量＞＝值　给变量设置值　　　
ｃ命令继续执行

启动ｇｄｂ
ｇｄｂ　　＜程序名称＞

ｇｄｂ　＜程序名称＞　ｃｏｒｅ文件

ｇｄｂ　＜程序名称＞　ｐｉｄ
ｇｄｂ -help帮助

如果一个要调试的文件以数字打头　就用./数字　　防止把文件当成进程读取

ｇｄｂ　－ｓ　ｆｉｌｅ　读取符号表

－ｅ　ｆｉｌｅ　把ｆｉｌｅ当作可执行文件　

－ｓｅ　ｆｉｌｅ　从文件ｆｉｌｅ中读取符号表，并当作可执行文件来使用

－ｃ　ｆｉｌｅ　把文件ｆｉｌｅ当成ｃｏｒｅ文件使用　进行分析

－ｐｉｄ　ｎｕｍｂｅｒ　
－ｐ　ｎｕｍｂｅｒ　　都是链接到一个进程

－ｃ｜ｘ　　ｆｉｌｅ　执行文件中的ｇｄｂ命令

－ｄ　ｄｉｒｅｃｔｏｒｔ　添加目录到源文件搜索路径

－ｍ｜ｍａｐｐｅｄ生成符号映像文件　在调试的程序目录下＜程序名．ｓｙｎｓ＞
－ｒ｜ｒｅａｄｎｏｗ　读取每个符号文件的整个符号表，这使启动慢　调试快

．ｓｙｎｅｓ文件一边以后使用的ｇｄｂ调用是：
ｇｄｂ　－ｂａｔｃｈ　－ｎｘ　－ｍａｐｐｅｄ　－ｒｅａｄｎｏｗ　程序名称
上面那条是创建一个.synes文件以便以后调试

－ｎｘ　批处理模式　

-batch 以批处理方式运行　　成功返回０　　否则返回非０

－－ａｒｇｓ　传递给程序的参数

－ｂａｕｄ　ｂｐｓ　设置远程调试的端口速率　单位以秒为单位
－ｔ　ｄｅｖｉｃｅ　把ｄｅｖｉｃｅ当作程序的标准输出
－ｔｕｉ　激活文本界面
－ｗｒｉｔｅ　打开可执行文件和Ｃｏｒｅ文件　可读写　
－ｓｔａｔｉｓｔｉｃｓ　没执行一次就统计时间和内存使用率
－ｖｅｒｓｉｏｎ　打印ｇｄｂ版本

进入ｇｄｂ交互命令
ｄｅｔａｃｈ　释放绑定的设备或进程
ｓｈｅｌｌ　＜命令＞　执行ｓｈｅｌｌ命令

设置命令日志
ｓｅｔ　ｌｏｇｉｎｇ　ｏｎ
ｓｅｔ　ｌｏｇｉｎｇ　ｏｆｆ
ｓｅｔ　ｌｏｇｉｎｇ　ｆｉｌｅ　＜ｆｉｌｅ＞　　设置ｌｏｇ的文件默认ｇｄｂ．ｔｘｔ

ｓｅｔ　ｌｏｇｇｉｎｇ　ｏｗｅｒｗｒｉｔｅ　［ｏｎ｜ｏｆｆ］　覆盖模式开关
ｓｅｔ　ｌｏｇｇｉｎｇ　ｒｅｄｉｒｅｃｔ　［ｏｎ｜ｏｆｆ］　如过ｏｎ只输出到日志　终端不输出

ｓｈｏｗ　ｌｏｇｇｉｎｇ　显示当前的ｌｏｇｇｉｎｇ　的设置值

ａｐｒｏｐｏｓ　ａｒｇｓ　匹配含有ａｒｇｓ正则式的命令

ｃｏｍｐｌｅｔｅ　ａｒｇｓ　列出以ａｒｇｓ开头　并且完整的命令

ｉｎｆｏ　ｒｅｇｉｓｔｅｒｓ　列出寄存器内容　
ｉｎｆｏ　ｂｒｅａｋｐｏｉｎｔ　类出断电
ｓｈｏｗ　ｇｄｂ自身的信息　　比如ｓｈｏｗ　ｒａｄｉｘ　显示采用的数制　ｓｅｔ　ｒａｄｉｘ可以设置数制

编译的时候加上－ｇ３　　或者　－ｇｄｗａｒｆ－２　选项就可以包含进宏

ｓｔａｒｔ　相当与在程序一开始处就设置了一个断点　再执行ｒｕｎ命令　　这样可以调试ｍａｉｎ之前的程序

ｓｅｔ　ａｒｇｓ　　如果ｒｕｎ　使用了参数　下一次执行ｒｕｎ会继承上一次的参数
这个名利是设置参数的命令　　如果不设置就会继承上一次的参数

ｓｅｔ　ｅｎｖ　　ｖａｒｎａｍｅ＝［］　设置环境变量

如ｓｅｔ　env USER=foo 告诉ｇｄｂ下次ｒｕｎ的时候它的用户是ｆｏｏ
ｕｎｓｅｔ　ｅｎｖ　　＜变量＞　　　　　　撤销环境变量

ｐｗｄ　显示工作目录
ｒｕｎ > outfile  重定向ｇｄｂ的输入输出

ｔｔｙ　　／ｄｅｖ／ｔｔｙｂ　　将输出重定向到其他ｔｔｙ
ａｔｔａｃｈ　＜ｐｒｏｃｅｓｓ－ｉｄ＞　　抓取运行时的程序　　指定ｐｉｄ
ｄｅｔａｃｈ　释放ＧＤＢ对进程的控制
ｋｉｌｌ　杀死子进程　　当你想调试ｃｏｒｅ　ｄｕｍｐ时这个命令很有用



对线程的调试
ｔｈｒｅａｄ　<threadno> 切换线程
ｉｎｆｏ　ｔｈｒｅａｄｓ　查询线程
ｔｈｒｅａｄ　ａｐｐｌｙ　［ｔｈｒｅａｄｎｏ］　［ａｌｌ］ａｇｒｓ　　对线程列表执行命令
ｓｅｔ　ｐｒｉｎｔ　ｔｈｒｅａｄ－ｅｖｅｎｔｓ　控制线程开始和结束打印信息　有＊号的表示当前线程
ｔｈｒｅａｄ　ａｐｐｌｙ［ｔｈｒｅａｄｎｏ］［ａｌｌ］ｃｏｍｍａｎｄ　可以在一个或者多个线程上执行命令
ｓｅｔ　ｔｈｒｅａｄ－ｅｖｅｎｔｓ　ｏｎ｜ｏｆｆ　开启关闭打印信息

调试子进程
ｓｅｔ　ｆｏｌｌｏｗ－ｆｏｒｋ－ｍｏｄｅ　ｐａｒｅｎｔ｜ｃｈｉｌｄ　这两个分别是ｆｏｒｋ之后调试父进程和子进程
ｓｅｔ　ｄｅｔａｃｈ－ｏｎ－ｆｏｒｋ　ｏｎ｜ｏｆｆ　　在这里ｏｎ　表示子进程或者父进程单独执行　　　ｏｆｆ表示一个被执行　一个被挂起
设置为ｏｆｆ时
ｉｎｆｏ　ｆｏｒｋ　查看进程
ｆｏｒｋ　ｆｏｒｋ－ｉｄ　切换到子进程
ｐｒｏｃｅｓｓ　ｐｏｒｃｅｓｓ－ｉｄ　切换到制定的ｐｒｏｃｅｓｓｉｄ的进程
ｄｅｔａｃｈ　ｆｏｒｋ　ｆｏｒｋ－ｉｄ　放弃调试子进程他会继续执行
ｄｅｌｅｔｅ　ｆｏｒｋ　ｆｏｒｋ－ｉｄ杀死子进程

设置检查点　在检查点生成程序的镜像　以后可以将程序回复到检查点继续执行
ｃｈｅｃｋｐｏｉｎｔ　＜ＩＤ＞　设置检查点　
ｒｅｓｔａｒｔ　　＜ＩＤ＞回到检查点执行
info checkpoints 查看检查点
ｄｅｌｅｔｅ　ｃｈｅｃｋｐｏｉｎｔ－ｉｄ　　删除检查点　进程ＩＤ　会改变

ｂｒｅａｋ　＜ｌｏｃａｔｉｏｎ＞　　　　ｌｏｃａｔｉｏｎ可以是行号　函数名　指令地址

ｂｒｅａｋ　．．．　ｉｆ　ｃｏｎｄ　　如果ｃｏｎｄ条件成立则设置断点
ｔｂｒｅａｋ　ａｒｇｓ　设置一次断点　　程序执行一次后删除断点
ｈｂｒｅａｋ　ａｒｇｓ　设置一个硬件支持的断点
ｔｈｂｒｅａｋ　ａｒｇｓ　硬件支持的只执行一次的断点
ｒｂｒｅａｋ　ｒｅｇｅｘ　在ｒｅｇｅｘ匹配的正则表达式上设置断点　也可以设置ｉｆ　ｃｏｎｄ条件

ｉｎｆｏ　ｗａｔｃｈｐｏｉｎｔ　［ｎ］　显示断电　检查点　监视点
ｓｅｔ　ｂｒｅａｋｐｏｉｎｔ　ｐｅｎｄｉｎｇ　ｏｎ　设置如果不能识别断点　自动挂起

监视点可以监视一个变量或者一个指针的变化　如果发生变化中断程序
ｗａｔｃｈ　ｅｘｐｒ　　见识ｅｘｐｒ变量或者函数等　如果发生变化的时候启动中断

ｗａｔｃｈ　ｅｘｐｒ　［ｔｈｒｅａｄ　ｔｈｒｅａｄｎｕｍ］当表达是在该线程中改变就发生中断

ｒｗａｔｃｈ　ｅｘｐｒ　［ｔｒｅｈａｄ　ｔｈｒｅａｄｎｕｍ］　程序读表达式的值时终端
ａｗａｔｃｈ　ｅｘｐｒ　［ｔｒｈｅａｄ　ｔｒｅｈａｄｎｕｍ］　读或写表达式的时候发生中断

ｉｎｆｏ　ｗａｔｃｈｐｏｉｎｔｓ　显示检查点

捕获点
ｃａｔｃｈ　＜ｅｖｅｎｔ＞　　ｅｖｅｎｔ可以是ｅｘｅｃ（调用），ｆｏｒｋ　ｖｆｏｒｋ

ｌｏａｄ
ｌｏａｄ　＜ｌｉｂｎａｍｅ＞　家在共享库
ｕｎｌｏａｄ
ｕｎｌｏａｄ　ｌｉｂｎａｍｅ　　卸载库
捕获点只运行一次

ｃｌｅａｒ　删除所有断点
ｄｅｌｅｔｅ　［ｂｒｅａｋｐｏｉｎｔｓ］　［ｒａｎｇｅ．．］删除指定断电


禁用　和　恢复断点　这样不必删除断点
ｅｎａｂｌｅ　［ｂｒｅａｋｐｏｉｎｔｓ］　［ｒａｎｇｅ．．．］　启动断电
ｄｉｓａｂｌｅ　［ｂｒｅａｋｐｏｉｎｔｓ］［ｒａｎｇｅ．．］关闭断点
ｅｎａｂｌｅ　［ｂｒｅａｋｐｏｉｎｔｓ］　ｏｎｃｅ　ｒａｎｇｅｓ．．　临时开启断点
ｅｎａｂｌｅ　［ｂｒｅａｋｐｏｉｎｔｓ］　ｄｅｌｅｔｅ　ｒａｎｇｅ．．　开启执行一次后删除
ｃｏｎｄｉｔｉｏｎ　＜ｂｎｕｍ断点号＞　＜表达式＞　　为断点　见识点捕获点设置条件
ｉｇｎｏｒｅ　＜ｂｎｕｍ＞　＜ｃｏｕｎｔ＞　将断点ｂｎｕｍ　在ｃｏｕｎｔ次不中断

断点命令列表
ｃｏｍｍａｎｄ　［ｂｎｕｍ］
．．．　ｃｏｍｍｄａｎｄ－ｌｉｓｔ　　　　这是断点发生后要执行的命令
ｅｎｄ　　列表结束

ｃ［ｉｇｎｏｒｅ－ｃｏｕｎｔ］　继续执行，并且参数设置该断点忽略执行的次数
ｆｇ［ｉｇｎｏｒｅ－ｃｏｕｎｔ］　设置在这个地址上的断点会被绕过
ｒｅｔｕｒｎ　从函数里返回
ｓ　＜ｃｏｕｎｔ＞
ｎ　＜ｃｏｕｎｔ＞
ｆｉｎｉｓｈ　继续执行　知道断点函数返回　若有返回值打印之
ｕ　

ｓｉ　调试一个机器指令　接着中断然后返回到调试器
ｎｉ
ｉｎｆｏ　ｓｉｇｎａｌｓ
ｉｎｆｏ　ｈａｎｄｌｅ

ｂｒｅａｋ　＜ｌｉｎｅｓｐｅｃ＞　ｔｈｒｅａｄ　＜ｔｈｒｅａｎｏ＞　指定线程指定行号
例子　ｂｒｅａｋ　ｆｒｉｋ．ｃ：１３　ｔｈｒｅａｄ　２８　ｉｆ　ａ＞ｂ


frame args 切换堆栈帧　并打印这个帧
select-frame　切换到一个帧　不打印

bt　打印每一帧
bt n　只打印最内层ｎ层帧
bt full n　打印ｎ个帧的数量

thread apply　打印线程的帧

